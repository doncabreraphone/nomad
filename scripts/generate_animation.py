#!/usr/bin/env python3
import sys
import re
import glob
import os
from rich.console import Console
from rich.panel import Panel
from rich.prompt import Prompt

def parse_frames_from_file(path, invert_colors=False):
    """Analiza un archivo .c y extrae todos los frames de animación que encuentra."""
    with open(path, "r") as f:
        content = f.read()

    # Patrón para encontrar todas las definiciones de arrays (ambos formatos)
    pattern = r'(?:uint8_t\s+\w+_map|const unsigned char\s+\w+)\s*\[\]\s*PROGMEM?\s*=\s*\{[^}]+\}'
    array_definitions = re.findall(pattern, content, re.DOTALL)
    
    if not array_definitions:
        return []

    all_frames = []
    for definition in array_definitions:
        hex_values = re.findall(r'0x([0-9A-Fa-f]{2})', definition)
        bytes_all = [int(h, 16) for h in hex_values]

        # Determinar si el frame tiene una paleta de colores (formato original)
        if 'const unsigned char' in definition:
            pixel_data = bytes_all  # Formato image2cpp, sin paleta
        else:
            pixel_data = bytes_all[8:1032]  # Formato original, con paleta

        if invert_colors:
            pixel_data = [~b & 0xff for b in pixel_data]
        
        all_frames.append(pixel_data)
        
    return all_frames

def write_output(frames, out_path, variable_name):
    lines = [f"# {out_path}", "# Autogenerated by generate_animation.py", ""]
    frame_vars = []
    frame_prefix = variable_name.lower().replace('_animation', '')

    for i, frame in enumerate(frames):
        var_name = f"{frame_prefix}_frame_{i}"
        frame_vars.append(var_name)
        byte_string = "b'''" + "".join([f"\\x{b:02x}" for b in frame]) + "'''"
        lines.append(f"{var_name} = bytearray({byte_string})")

    lines.append("")
    lines.append(f"{variable_name} = [")
    for var_name in frame_vars:
        lines.append(f"    {var_name},")
    lines.append("]")

    with open(out_path, "w") as f:
        f.write("\n".join(lines))

def main():
    console = Console()

    # --- Selección de Animación ---
    console.print(Panel("Animations available in 'assets/':", title="[bold cyan]Generate Animation[/bold cyan]"))
    
    animation_files = glob.glob("assets/*.c")
    animation_names = [os.path.basename(f).replace('.c', '') for f in animation_files]

    if not animation_names:
        console.print("[bold red]Error:[/bold red] No animation files (.c) found in 'assets/' folder.")
        sys.exit(1)

    for i, name in enumerate(animation_names):
        console.print(f"  [yellow]{i+1}[/yellow]. {name}")

    choice = Prompt.ask("\n[bold]Choose an animation to generate[/bold]", choices=[str(i+1) for i in range(len(animation_names))])
    selected_animation = animation_names[int(choice) - 1]

    # --- Selección de Inversión ---
    invert_choice = Prompt.ask("\n[bold]Invert colors?[/bold]", choices=["y", "n"], default="n")
    invert = (invert_choice.lower() == 'y')

    # --- Procesamiento ---
    output_filename = f"{selected_animation}_animation.py"
    variable_name = selected_animation.upper() + '_ANIMATION'
    single_file_path = f'assets/{selected_animation}.c'

    console.print(Panel(f"  - Source: {single_file_path}\n  - Output: {output_filename}\n  - Invert: {'Yes' if invert else 'No'}", title="[bold cyan]Processing[/bold cyan]"))

    frames = parse_frames_from_file(single_file_path, invert_colors=invert)

    if not frames:
        console.print(f"[bold red]Error:[/bold red] No valid animation frames found in the source file.")
        sys.exit(1)

    write_output(frames, output_filename, variable_name)
    console.print(f"\n[bold green]✓ Successfully generated '{output_filename}' with {len(frames)} frames.[/bold green]")

if __name__ == "__main__":
    main()