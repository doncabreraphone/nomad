import sys
import re
import glob
from rich.console import Console
from rich.panel import Panel

def parse_c_array(path):
    with open(path, "r") as f:
        content = f.read()

    m = re.search(r'uint8_t\s+\w+_map\[\]\s*=\s*\{([^}]+)\}', content, re.DOTALL)
    if not m:
        return None

    hex_values = re.findall(r'0x([0-9A-Fa-f]{2})', m.group(1))
    bytes_all = [int(h, 16) for h in hex_values]

    # Extraemos solo los datos de los píxeles (los 1024 bytes después de la paleta)
    pixel_data = bytes_all[8:1032]

    # --- LÍNEA MÁGICA ---
    # Invertimos cada bit de cada byte. El operador '~' hace la inversión bit a bit.
    # El '& 0xff' es para asegurar que el resultado se mantenga como un byte de 8 bits.
    inverted_pixel_data = [~b & 0xff for b in pixel_data]
    
    return inverted_pixel_data

def write_output(frames, out_path, variable_name):
    lines = [f"# {out_path}", "# Autogenerated by generate_animation.py", ""]
    frame_vars = []
    frame_prefix = variable_name.lower().replace('_animation', '')

    for i, frame in enumerate(frames):
        var_name = f"{frame_prefix}_frame_{i}"
        frame_vars.append(var_name)
        byte_string = "b'''" + "".join([f"\\x{b:02x}" for b in frame]) + "'''"
        lines.append(f"{var_name} = bytearray({byte_string})")

    lines.append("")
    lines.append(f"{variable_name} = [")
    for var_name in frame_vars:
        lines.append(f"    {var_name},")
    lines.append("]")

    with open(out_path, "w") as f:
        f.write("\n".join(lines))

def main():
    console = Console()

    if len(sys.argv) != 2:
        console.print("[bold red]Usage:[/bold red] python scripts/generate_animation.py <output_filename.py>")
        console.print("[bold cyan]Example:[/bold cyan] python scripts/generate_animation.py travel_animation.py")
        sys.exit(1)

    output_filename = sys.argv[1]
    
    if not output_filename.endswith('_animation.py'):
        console.print(f"[bold red]Error:[/bold red] Output filename must end with '_animation.py'")
        sys.exit(1)

    # Derive names from the output filename
    prefix = output_filename.replace('_animation.py', '')
    variable_name = prefix.upper() + '_ANIMATION'
    
    # Find and sort source C files naturally from the assets directory
    source_files_pattern = f'assets/{prefix}_*.c'
    
    def sort_key(filename):
        match = re.search(r'_(\d+)\.c$', filename)
        return int(match.group(1)) if match else -1
        
    source_files = sorted(glob.glob(source_files_pattern), key=sort_key)

    if not source_files:
        console.print(f"[bold red]Error:[/bold red] No source files found matching '[yellow]{source_files_pattern}[/yellow]'")
        sys.exit(1)

    file_list_str = "\n".join([f"  - {p}" for p in source_files])
    console.print(Panel(file_list_str, title=f"[bold cyan]Found {len(source_files)} source files[/bold cyan]", border_style="blue", title_align="left"))

    frames = []
    for p in source_files:
        frame = parse_c_array(p)
        if frame:
            frames.append(frame)

    # Write to the project root
    write_output(frames, output_filename, variable_name)
    console.print(f"\n[bold green]✓ Successfully generated '{output_filename}' with {len(frames)} frames.[/bold green]")

if __name__ == "__main__":
    main()